
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">
    <link rel="shortcut icon" href="ico/regula_favicon.png">

    <title>Regula: A better way to validate forms</title>

    <!-- Bootstrap core CSS -->
    <link href="bootstrap/css/bootstrap.css" rel="stylesheet">

    <link href="css/regula.css" rel="stylesheet">

    <script src="https://google-code-prettify.googlecode.com/svn/loader/run_prettify.js"></script>
    <script src="js/jquery-2.0.3.min.js"></script>

    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
      <script src="bootstrap/assets/js/html5shiv.js"></script>
      <script src="bootstrap/assets/js/respond.min.js"></script>
    <![endif]-->
  </head>

  <body>

    <div class="container">

      <!-- Static navbar -->
      <div class="navbar navbar-default">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="#"><strong>Regula</strong></a>
        </div>
        <div class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
            <li><a href="./index.html">Home</a></li>
            <li><a href="./getting-started">Getting Started</a></li>
            <li class="active"><a href="#">Documentation</a></li>
            <li><a href="#">Examples</a></li>
          </ul>
          <ul class="nav navbar-nav navbar-right">
            <li><a href="#">Download</a></li>
            <li><a href="#">Source</a></li>
            <li><a href="#">FAQ</a></li>
            <li><a href="#">Support</a></li>
          </ul>
        </div><!--/.nav-collapse -->
      </div>

      <div class="row">
          <div class="col-md-12">
              <div id="documentation" class="panel regula-panel-primary documentation">

                  <hr />
                  <h1>Regula Documentation</h1>
                  <h3>Table of Contents</h3>
                  <h4>1.3</h4>
                  <hr />

                  <ol class="toc">
                      <li class="toc-item"><a href = "./documentation.html#overview">Overview</a></li>
                      <li class="toc-item"><a href = "./documentation.html#configuration">Configuring Regula</a></li>
                      <li class="toc-item"><a href = "./documentation.html#primary">Primary concepts</a>
                          <ol class="toc">
                              <li class="toc-item"><a href = "./documentation.html#constraints">Constraints</a>
                                  <ol class="toc">
                                      <li class="toc-item"><a href = "./documentation.html#element">Element constraints</a></li>
                                      <li class="toc-item"><a href = "./documentation.html#formSpecific">Form-specific constraints</a></li>
                                      <li class="toc-item"><a href = "./documentation.html#html5">HTML5 constraints</a></li>
                                      <li class="toc-item"><a href = "./documentation.html#parameters">Parameters</a></li>
                                      <li class="toc-item"><a href = "./documentation.html#optional">Optional, common parameters</a></li>
                                      <li class="toc-item"><a href = "./documentation.html#groups">Validation groups</a></li>
                                      <li class="toc-item"><a href = "./documentation.html#custom">Custom constraints</a></li>
                                      <li class="toc-item"><a href = "./documentation.html#overriding">Overriding constraints</a></li>
                                      <li class="toc-item"><a href = "./documentation.html#asynchronous">Asynchronous constraints</a></li>
                                      <li class="toc-item"><a href = "./documentation.html#compound">Compound constraints</a></li>
                                      <li class="toc-item"><a href = "./documentation.html#validators">Validators</a></li>
                                  </ol>
                              </li>
                              <li class="toc-item"><a href = "./documentation.html#binding">Binding</a>
                                  <ol class="toc">
                                      <li class="toc-item"><a href = "./documentation.html#inline">Inline</a></li>
                                      <li class="toc-item"><a href = "./documentation.html#programmatic">Programmatic</a></li>
                                  </ol>
                              </li>
                              <li class="toc-item"><a href = "./documentation.html#validation">Validation</a>
                                  <ol class="toc">
                                      <li class="toc-item"><a href = "./documentation.html#syncValidation">Synchronous</a></li>
                                      <li class="toc-item"><a href = "./documentation.html#asyncValidation">Asynchronous</a></li>
                                      <li class="toc-item"><a href = "./documentation.html#delegatedValidation">Delegated</a></li>
                                  </ol>
                              </li>
                          </ol>
                      </li>
                      <li class="toc-item"><a href = "./documentation.html#builtIn">Built-in Constraints</a>
                          <ol class="toc">
                              <li class="toc-item"><a href = "./documentation.html#required"><code>@Required</code></a></li>
                              <li class="toc-item"><a href = "./documentation.html#checked"><code>@Checked</code></a></li>
                              <li class="toc-item"><a href = "./documentation.html#selected"><code>@Selected</code></a></li>
                              <li class="toc-item"><a href = "./documentation.html#notblank"><code>@NotBlank</code></a></li>
                              <li class="toc-item"><a href = "./documentation.html#blank"><code>@Blank</code></a></li>
                              <li class="toc-item"><a href = "./documentation.html#max"><code>@Max</code></a></li>
                              <li class="toc-item"><a href = "./documentation.html#min"><code>@Min</code></a></li>
                              <li class="toc-item"><a href = "./documentation.html#range"><code>@Range</code></a></li>
                              <li class="toc-item"><a href = "./documentation.html#integer"><code>@Integer</code></a></li>
                              <li class="toc-item"><a href = "./documentation.html#real"><code>@Real</code></a></li>
                              <li class="toc-item"><a href = "./documentation.html#alpha"><code>@Alpha</code></a></li>
                              <li class="toc-item"><a href = "./documentation.html#numeric"><code>@Numeric</code></a></li>
                              <li class="toc-item"><a href = "./documentation.html#alphaNumeric"><code>@AlphaNumeric</code></a></li>
                              <li class="toc-item"><a href = "./documentation.html#digits"><code>@Digits</code></a></li>
                              <li class="toc-item"><a href = "./documentation.html#step"><code>@Step</code></a></li>
                              <li class="toc-item"><a href = "./documentation.html#length"><code>@Length</code></a></li>
                              <li class="toc-item"><a href = "./documentation.html#pattern"><code>@Pattern</code></a></li>
                              <li class="toc-item"><a href = "./documentation.html#email"><code>@Email</code></a></li>
                              <li class="toc-item"><a href = "./documentation.html#url"><code>@URL</code></a></li>
                              <li class="toc-item"><a href = "./documentation.html#past"><code>@Past</code></a></li>
                              <li class="toc-item"><a href = "./documentation.html#future"><code>@Future</code></a></li>
                              <li class="toc-item"><a href = "./documentation.html#completelyFilled"><code>@CompletelyFilled</code></a></li>
                              <li class="toc-item"><a href = "./documentation.html#passwordMatch"><code>@PasswordsMatch</code></a></li>
                          </ol>
                      </li>
                      <li class="toc-item" data-content-id="html5Constraints">HTML5 Constraints
                          <ol class="toc">
                              <li class="toc-item"><a href = "./documentation.html#html5Required"><code>@HTML5Required</code></a></li>
                              <li class="toc-item"><a href = "./documentation.html#html5Email"><code>@HTML5Email</code></a></li>
                              <li class="toc-item"><a href = "./documentation.html#html5URL"><code>@HTML5URL</code></a></li>
                              <li class="toc-item"><a href = "./documentation.html#html5MaxLength"><code>@HTML5MaxLength</code></a></li>
                              <li class="toc-item"><a href = "./documentation.html#html5Pattern"><code>@HTML5Pattern</code></a></li>
                              <li class="toc-item"><a href = "./documentation.html#html5Max"><code>@HTML5Max</code></a></li>
                              <li class="toc-item"><a href = "./documentation.html#html5Min"><code>@HTML5Min</code></a></li>
                              <li class="toc-item"><a href = "./documentation.html#html5Step"><code>@HTML5Step</code></a></li>
                          </ol>
                      </li>
                      <li class="toc-item" data-content-id="functions">Functions
                          <ol class="toc">
                              <li class="toc-item"><a href = "./documentation.html#regulaConfigure"><code>regula.configure</code></a></li>
                              <li class="toc-item"><a href = "./documentation.html#regulaBind"><code>regula.bind</code></a></li>
                              <li class="toc-item"><a href = "./documentation.html#regulaUnbind"><code>regula.unbind</code></a></li>
                              <li class="toc-item"><a href = "./documentation.html#regulaIsBound"><code>regula.isBound</code></a></li>
                              <li class="toc-item"><a href = "./documentation.html#regulaCustom"><code>regula.custom</code></a></li>
                              <li class="toc-item"><a href = "./documentation.html#regulaOverride"><code>regula.override</code></a></li>
                              <li class="toc-item"><a href = "./documentation.html#regulaCompound"><code>regula.compound</code></a></li>
                              <li class="toc-item"><a href = "./documentation.html#regulaValidate"><code>regula.validate</code></a></li>
                          </ol>
                      </li>
                      <li class="toc-item" data-content-id="objects">Objects
                          <ol class="toc">
                              <li class="toc-item"><a href = "./documentation.html#constraint"><code>Constraint</code></a></li>
                              <li class="toc-item"><a href = "./documentation.html#group"><code>Group</code></a></li>
                              <li class="toc-item"><a href = "./documentation.html#dateFormat"><code>DateFormat</code></a></li>
                              <li class="toc-item"><a href = "./documentation.html#exception"><code>Exception</code></a></li>
                              <li class="toc-item"><a href = "./documentation.html#constraintViolation"><code>ConstraintViolation</code></a></li>
                              <li class="toc-item"><a href = "./documentation.html#validator"><code>validator</code></a></li>
                          </ol>
                      </li>
                  </ol>

                  <hr />
                  <div id="overview" >
                      <h2>1. Overview</h2>

                      <p><strong>Regula</strong>is a powerful client-side validation library, where validation constraints can be attached <em>directly</em>to <code>input</code>
                         elements. This is similar to how validation can currently be attached to elements using <a href="http://diveintohtml5.info/forms.html">HTML5 validation
                         constraints</a>. However, Regula supports many-more advanced validation-features than can be provided by HTML5. Furthermore, the semantics of validation
                         is directly conveyed via markup, instead of being bound programmatically through JavaScript (i.e., the way many existing validation-libraries work).</p>

                      <p>Some of the advanced features supported by Regula include:

                      <ul>
                          <li>Custom constraints</li>
                          <li>Compound constraints</li>
                          <li>Validation groups</li>
                          <li>Asynchronous validation</li>
                      </ul>

                      Furthermore, all of these advanced capabilities can be encapsulated within custom constraints and used directly in markup.
                      </p>
                  </div>
                  <hr />
                  <div id="configuration" >
                      <h2>2. Configuring Regula</h2>

                      <p><strong>Regula</strong>pretty much works as you would expect out of the box. The only configuration options currently supported are the
                         <code>validateEmptyFields</code>and <code>enableHTML5Validation</code>option.</p>

                      <p>The <code>validateEmptyFields</code>option controls Regula's validation behavior in the context of empty <code>input</code>-fields. Sometimes, it is
                         desirable to validate <code>input</code>only if they are not empty. Setting <code>validateEmptyFields</code>to <code>false</code> will make Regula
                         validate non-empty fields only. This can be done as follows:</p>

                          <pre class="prettyprint">
  regula.configure({
      validateEmptyFields: false
  });</pre>

                       <p><strong>Note:</strong>The default value of this flag is <code>true</code>, which means that empty fields always validated. This behavior can be
                          controlled on a per-constraint basis by using the <code>ignoreEmpty</code>optional parameter. For more information, see <a href="./documentation.html#optional">&#167;3.1.5</a>.</p>

                       <p>The <code>enableHTML5Validation</code>option controls whether Regula will recognize HTML5 validation attributes like <code>required</code>. The default
                          value for this option is <code>true</code>, but it can be turned off like so:</p>

                          <pre class="prettyprint">
  regula.configure({
      enableHTML5Validation: false
  });</pre>
                  </div>
                  <hr />
                  <div id="primary" >
                      <h2>3. Primary Concepts</h2>

                      <p><strong>Regula</strong>is centered around a few primary concepts, and understanding these concepts will help you use Regula effectively. Subsequent
                          sub-sections will go over each of these concepts.</p>
                  </div>
                  <div id="constraints" >
                      <h3>3.1 Constraints</h3>

                      <p><strong>Constraints</strong>form the central part of Regula. A constraint describes a set of rules that the value of an <code>input</code>element must
                          conform to. It can also mandate that the element must be in a certain state (for example, it must be <em>checked</em>in the case of a checkbox). Regula
                          comes with a set of predefined constraints that are sufficient for most validation needs. However, you are able to create your own constraints (custom
                          constraints) for any custom-validation needs. These custom constraints that you have created, can be referenced in markup as well. Subsequent sections
                          will go into more detail about the different aspects of constraints in Regula.

                          When used in markup, constraints start with <code>@</code>. For example, the following <code>input</code>element has the <code>@Required</code>and
                          <code>@Range</code>constraints:

                      <pre class="prettyprint">
  &lt;input type="text" data-constraints="@Required @Range(min=5, max=10) /&gt;</pre>

                  </div>
                  <div id="element" >
                      <h4>3.1.1 Element constraints</h4>

                      <p><strong>Element constraints</strong>are the most-common form of constraint. These are constraints that apply to a single <code>input</code>, or
                          <code>select</code>element. What this means is that the <a href="./documentation.html#validators">validator</a>for that constraint performs a validation
                          check only against the element that the constraint is bound to. Also, in the <a href="./documentation.html#validators">validator</a>for a custom
                          element-constraint, <code>this</code>will refer to the element that is bound to the constraint.</p>
                      
                      <p>When validation fails for an element constraint, the <code>ConstraintViolation</code>object's <code>failingElements</code>property will only contain a
                         single element, i.e., the element that failed validation.</p>
                     
                      <strong>Note:</strong>For more information regarding the <code>ConstraintViolation</code>object, see <a href="./documentation.html#constraintViolation">&#167;7.5</a>.
                      </p>
                  </div>
                  <div id="formSpecific" >
                      <h4>3.1.2 Form-specific constraints</h4>

                      <p><strong>Form-specific constraints</strong>are a form of constraint that apply to an entire <code>form</code>element. These are typically used when it makes
                         sense to validate the state of the form as a whole. In the <a href="./documentation.html#validators">validator</a>for a custom form-specific constraint,
                         <code>this</code>will refer to the <code>form</code>element that is bound to the constraint.</p>

                      <p>When validation fails for a form-specific constraint, the <code>ConstraintViolation</code>object's <code>failingElements</code>property will contain all
                         elements that failed validation.</p>

                      <strong>Note:</strong>For more information regarding the <code>ConstraintViolation</code>object, see <a href="./documentation.html#constraintViolation">&#167;7.5</a>.
                  </div>
                  <div id="html5" >
                      <h4>3.1.3 HTML5 constraints</h4>

                      <p><strong>HTML5 constraints</strong>allow you to use native HTML5 validation-constraints in Regula. Keep in mind, however, that <strong>Regula is not an HTML5
                         shim</strong>. Regula <em>recognizes</em>native HTML5 constraints and incorporates them into its validation lifecycle <em>if the browser supports them natively,
                         or via a shim</em>. The reasoning behind this design decision is that HTML5 validation isn't limited to input validation; it includes specific view-elements as
                         well (such as a calendar for <code>date</code>types). Emulating these elements is out of the scope of what Regula is trying to accomplish.</p>

                      <p>HTML5 constraints in Regula can be used in two forms. One form is the standard form (i.e., how HTML5 constraints are regularly used) and looks like this:</p>

                      <pre class="prettyprint">
  &lt;input type="text" required="true" /&gt;</pre>


                      <p>Internally, Regula converts the <code>required</code>attribute into the <code>@HTML5Required</code>constraint. Instead of using the standard form, you can
                         use the "wrapped" versions of the HTML5 constraints as well. This form is desirable since it allows you to easily use other features of Regula like
                         <a href="./documentation.html#groups">validation groups</a>, <a href="./documentation.html#optional">labels</a>, and <a href="./documentation.html#optional">custom messages</a>:</p>

                      <pre class="prettyprint">
  &lt;input type="text"
      data-constraints='@HTML5Required(
          label="username", 
          message="The {label} is required!", 
          groups=[MyGroup, OtherGroup]
      )' 
  /&gt;</pre>

                  </div>
                  <div id="parameters" >
                      <h4>3.1.4 Parameters</h4>

                      <p><strong>Parameters</strong>allow you to pass information into a constraint and/or modify its behavior. Some constraints have optional parameters, whereas
                         others will have required parameters. For example, the <code>@Range</code>constraint expects a <code>max</code>and a <code>min</code> parameter. If required
                         constraints are not provided to a constraint, Regula will throw an error during binding.</p>Parameters are not explictly typed, but in general are similar to
                         JavaScript types. Parameters can also be used inside the constraint's failure-message through interpolation. This gives you the ability to provide custom
                         messages that change dynamically based on the parameter values supplied to the constraint (for more information, look at <code>message</code>in
                         <a href="./documentation.html#optional">&#167;3.1.5</a>).</p>When defining your own custom constraint, you can specify the parameters that the constraint
                         accepts. For more information, see <a href="./documentation.html#custom">&#167;3.1.7</a>.

                      <p><strong>Note:</strong>Regular-expression parameters are currently not typed as JavaScript <code>RegExp</code>objects; this is an oversight and will be fixed
                         in a future release. Currently it is required that the value be converted into a <code>RegExp</code>object by using the <code>RegExp</code>object's
                         constructor.

                  </div>
                  <div id="optional" >
                      <h4>3.1.5 Optional, common parameters</h4>

                      <p><strong>Optional, common parameters</strong>are parameters that are recognized by all constraints (including custom and compound constraints). They are not
                         necessary, but can be included if you want to customize certain aspects of your constraint, or use other features. Currently-supported optional parameters
                         are:</p>

                      <p>
                          <ul>
                              <li><code>label</code>: A friendly name for the input element that is undergoing validation. This value has a default value that matches up with the
                                  element that the constraint is attached to, and is used in the validation failure-message. You can override the default value by providing one that
                                  is more semantically-appropriate (i.e., actually describing what the input element is used for).</li>
                              <li><code>message</code>: The failure message when a constraint has failed validation. This is the message that you would display to the user if a
                                  particular input element does not satisfy the constraints attached to it. You can use parameter interpolation inside this failure message as well.
                                  For example, for the <code>@Range</code>constraint, which has the <code>max</code>and <code>min</code> parameters, you can provide a failure
                                  message like so <code>"{label} should be between {max} and {min}."</code>. If the constraint fails validation, <code>{label}</code>, <code>{max}</code>,
                                  and <code>{min}</code>will be replaced with the actual values that were supplied to those parameters.</li>
                              <li><code>groups</code>: Used to specify validation groups, which helps you segment validation by targeting specific subsets of input elements. For more
                                  information, see <a href="./documentation.html#groups">&#167;3.1.6</a>which deals with this topic).</li>
                              <li><code>ignoreEmpty</code>: Used to specify whether this constraint should be validated if the value of the input element is empty. If <code>ignoreEmpty</code>
                                  is set to <code>true</code>, this constraint will not be validated if the input element that it is attached to, has an empty value.</li>
                          </ul>
                      </p>
                  </div>
                  <div id="groups" >
                      <h4>3.1.6 Validation groups</h4>

                      <p><strong>Validation groups</strong>give you the ability to segment validation and are specified using the <code>groups</code>parameter. Using groups, you can
                         assign certain constraints to one or more groups and target those subsets individually during validation. For example, consider an order form where you have
                         the user's name, address, and payment information. You can assign the constraints related to the customer's name and address to one group, and the payment
                         information to another. Then you will be able to validate each group individually. Another use case is if you have multiple forms on one page; you can assign
                         the input elements to a group that reflects the fact that they belong to a particular form.</p>
                     
                      <p>Groups do not need to be pre-defined anywhere and can be used in an ad-hoc manner when attaching a constraint to an element. By default, all constraints belong
                         to the <code>Default</code>group; this is the only built-in group in Regula. When you specify groups while binding, they are reified and will be available for
                         use in <code>regula.Group</code>. For example, if you specified a group called <code>Address</code>, it would be available under <code>regula.Group.Address</code>
                         and can be used with Regula's JavaScript API. Examples that involve the usage of groups are shown below.</p>

                      <strong>Specifying groups in HTML</strong>
                      <pre class="prettyprint">
  &lt;input type="text"
      data-constraints='@HTML5Required(
          label="username", 
          message="The {label} is required!", 
          groups=[MyGroup, OtherGroup]
      )' 
  /&gt;</pre>


                      <strong>Using groups in JavaScript</strong>
                      <pre class="prettyprint">
 //only validate those constraints in MyGroup
 regula.validate({groups: [regula.Group.MyGroup]});</pre>


                  </div>
                  <div id="custom" >
                      <h4>3.1.7 Custom constraints</h4>

                      <p><strong>Custom constraints</strong>let you specify custom validation rules. Once you have defined a custom constraint, you can use it just like one of Regula's
                      built-in constraints. Using custom constraints you can specify your own validation rules, and even perform things like conditional or server-side validation (via an
                      asynchronous custom-constraint). Regula's custom constraints are quite flexible; you can even define the kind of parameters that you want your custom constraint to
                      accept. Regula promotes reuse and encapsulation with its implementation of custom constraints. Once you define your custom constraint, you can use it on any input
                      element. Secondly, all of your constraint's validation logic is neatly encapsulated in one place. Some examples are shown below:</p>

                      <strong>Simple example of a custom constraint</strong>
                      <pre class="prettyprint">
 regula.custom({
    name: "MustBe42",
    defaultMessage: "The answer must be equal to 42",
    validator: function() {
       return this.value == 42;
    }
 });</pre>

                      <p>To use it in HTML, all you have to do is:</p>

                      <pre class="prettyprint">
 &lt;input id = "theAnswerToLifeTheUniverseAndEverything"
        name = "theAnswerToLifeTheUniverseAndEverything"
        value = ""
        data-constraints = "@MustBe42" /&gt;
                      </pre>

                      <strong>Defining a custom constraint that accepts parameters</strong>
                      <pre class="prettyprint">
 regula.custom({
    name: "DivisibleBy",
    defaultMessage: "{label} must be divisible by {divisor}",
    params: ["divisor"],
    validator: function(params) {
       var divisor = params["divisor"];
       return (this.value % divisor) == 0;
    }
 });</pre>

                      <p>Here we have defined a custom constraint called <code>@DivisibleBy</code>which accepts one parameter called <code>divisor</code>. Notice that the <code>message</code>
                      parameter includes strings like <code>{label}</code>and <code>{divisor}</code>This means that when the constraint fails, those strings are replaced by the actual values
                      with which the constraint was attached. Here's an example of the constraint in use:</p>

                      <pre class="prettyprint">
 &lt;input id = "number"
        name = "number"
        value = ""
        data-constraints = '@DivisibleBy(divisor=3, label="The Number")' /&gt;</pre>

                      <p>As mentioned before, you can also define an asynchronous constraint. This is useful if you want to perform server-side validation of data:</p>

                      <pre class="prettyprint">
 regula.custom({
     name: "MyAsyncConstraint",
     async: true,
     defaultMessage: "The asynchronous constraint failed.",
     validator: function(params, validator, callback) {
         //Using jQuery as an example
         jQuery.ajax({
             url: myUrl,
             dataType: "jsonp",
             success: function(data) {
                 //Use the callback to pass the result of validation back to
                 //regula.
                 callback(data.success)
             }
         });
     }
 });</pre>

                      <p>For more information on custom constraints, take a look at the documentation for <code>regula.custom</code>in <a href="./documentation.html#regulaCustom">&#167;6.5</a>,
                      and for more information on asynchronous constraints, take a look at <a href="./documentation.html#asynchronous">&#167;3.1.9</a></p>

                  </div>
                  <div id="overriding" >
                      <h4>3.1.8 Overriding constraints</h4>

                      <p>Regula allows you to <strong>override</strong>constraints. This means that you can redefine the behavior of an already-existing constraint. For built-in constraints,
                      overriding is limited to the <code>defaultMessage</code>property. However, you can override any attribute of a custom constraint.</p>

                      <p>Here's an example where we override the <code>defaultMessage</code>of the <code>@PasswordsMatch</code>constraint:</p>

                      <pre class="prettyprint">
 regula.override({
     name: "PasswordsMatch",
     defaultMessage: "Your passwords do not match."
 });</pre>

                      <p>Here's another example where we override the <code>validator</code>of the <code>@DivisibleBy</code>custom constraint described in
                         <a href="./documentation.html#custom">&#167;3.1.7</a>:</p>

                      <pre class="prettyprint">
 regula.override({
     name: "DivisibleBy",
     validator: function(params) {
        var divisor = params["divisor"];
        var inputElement = this;
        return (inputElement.value % divisor) == 0;
     }
 });</pre>
                      For more information, take a look at documentation for <code>regula.override</code>in <a href="./documentation.html#regulaOverride">&#167;6.6</a></p>
                  </div>
                  <div id="asynchronous" >
                      <h4>3.1.9 Asynchronous constraints</h4>

                      <p><strong>Asynchronous constraints</strong>allow you to perform validation asynchronously. Typically this is done if you want to perform server-side validation from the
                         client side, or if you do not know when the validation operation will complete; only that it happens at some time in the future. Using asynchronous constraints you can
                         perform whatever asynchronous validation you need, and then report the result back to Regula using a callback. Defining an asynchronous constraint is pretty simple:</p>

                       <pre class="prettyprint">
 regula.custom({
     name: "MyAsyncConstraint",
     async: true,
     defaultMessage: "The asynchronous constraint failed.",
     validator: function(params, validator, callback) {
         //Using jQuery as an example
         jQuery.ajax({
             url: myUrl,
             dataType: "jsonp",
             success: function(data) {
                 //Use the callback to pass the result of validation back to
                 //regula.
                 callback(data.success)
             }
         });
     }
 });</pre>
                      <p>You can then use this constraint in HTML just like any other constraint.</p>
                  </div>
                  <div id="compound" >
                      <h4>3.1.10 Compound constraints</h4>

                      <p><strong>Compound constraints</strong>are constraints that are composed of other constraints (which may include other compound constraints). If you see yourself using
                         the same set of constraints over and over again, it might be helpful to combine them into a compound constraint, and simply use that instead. Here's an example of a
                         simple compound-constraint:</p>

                      <pre class="prettyprint">
 regula.compound({
     name: "SimpleCompoundConstraint",
     constraints: [
         {constraintType: regula.Constraint.Numeric},
         {constraintType: regula.Constraint.NotEmpty}
    ]
 });</pre>

                      <p>If any of the composing constraints require parameters, you can specify them when you create the compound constraint (in which case those parameters will remain the same
                         for each use of the constraint) or you can specify them when you actually use the constraint (in which case you can use different values on a per-instance basis).</p>

                      <strong>Here, the <code>min</code>and <code>max</code>parameters are hardcoded to <code>2</code> and <code>15</code> for each invocation.</strong>
                      <pre class="prettyprint">
 regula.compound({
     name: "AnotherCompoundConstraint",
     constraints: [
        {constraintType: regula.Constraint.NotEmpty},
        {constraintType: regula.Constraint.Range,
         params: {min: 2, max: 15}
        }
    ]
 });</pre>

                      <strong>Here, the <code>min</code>and <code>max</code>parameters are specified as actual parameters to the compound constraint. So it is not necessary to hardcode them
                      since you can specify them in HTML</strong>
                      <pre class="prettyprint">
 regula.compound({
     name: "OneMoreCompoundConstraint",
     params: ["max", "min"],
     constraints: [
         {constraintType: regula.Constraint.NotEmpty},
         {constraintType: regula.Constraint.Range} //Notice that we don't need to
                                                   //specify max and min because
                                                   //the parent constraint already
                                                   //accepts them as parameters
      ]
});</pre>
                      <pre class="prettyprint">
 &lt;input id = "myTextField"
        name = "myTextField"
        value = ""
        data-constraints = "@OneMoreCompoundConstraint(min=5, max=10)" /&gt;</pre>
                  </div>

                  <div id="validators" >
                      <h4>3.1.11 Validators</h4>

                      <p><strong>Validators</strong>are validation functions that you can have access to from within a validator. They are the functional counterparts to constraints. Using validators,
                         you can directly invoke a validation function that corresponds to a particular constraint (but only within the context of a validator). A good use-case is in the event you need
                         to perform some sort of conditional validation. Prior to Regula 1.3, conditional validation required duplication of built-in validation. Using validators, this is no-longer the
                         case.</p>

                      <p>Let's look at some examples:</p>

                      <strong>Here, we're creating a new custom-constraint that performs conditional validation based on the status of a checkbox:</strong>
                      <pre class="prettyprint">
 regula.custom({
     name: "ConditionalRequired",
     params: ["checkBoxId"]
     defaultMessage: "This is required.",
     validator: function(params, validator) {
         var valid = true;
         //Using jQuery as an example
         if(jQuery("#" + params["checkBoxId"]).is(":checked")) {
             //must pass in 'this' to the validator so that it knows
             //which element it has to validate
             return validator.required(this, params, validator);
         }

         return valid;
     }
 });</pre>
 <pre class="prettyprint">
 &lt;input id = "age"
     name = "age"
     value = ""
     data-constraints = "@Numeric @ConditionalRequired(checkBoxId='iWantToDrinkAlcohol')" /&gt;</pre>

                      <p>Custom validators are automatically added to the <code>validators</code>object. If, for example, you had a custom constraint called <code>@MyCustomConstraint</code>, then the
                         corresponding validator can be invoked via <code>validators.myCustomConstraint</code>.</p>

                  </div>
                  <div id="binding" >
                      <h3>3.2 Binding</h3>

                      <p><strong>Binding</strong>attaches validation constraints to input elements. There are two forms of binding: <b>inline</b>and <b>programmatic</b>.
                  </div>
                  <div id="inline" >
                      <h4>3.2.1 Inline Binding</h4>

                      <p><strong>Inline</strong>binding is performed through HTML. That is, constraints are attached to the element directly using the <code>data-constraints</code>attribute. This is the
                      preferred way of binding since validation constraints are immediately apparent from viewing the HTML code. This is very similar to HTML5 validation constraints.</p>
                  </div>
                  <div id="programmatic" >
                      <h4>3.2.2 Programmatic Binding</h4>

                      <p><strong>Programmatic</strong>binding is performed through JavaScript using the Regula API. Using the API, you can dynamically-bind constraints to elements. Programmatic binding
                      does give you a finer degree of control (especially when overwriting existing-bindings) but since the binding code exists in JavaScript, validation constraints for HTML elements aren't
                      immediately apparent. For more information, see <a href="./documentation.html#regulaBind">&#167;6.2</a>.</p>
                  </div>
                  <div id="validation" >
                      <h3>3.3 Validation</h3>

                      <p><strong>Validation</strong>is the process through which Regula applies validation-constraints to input elements. There are three forms of validation: <strong>synchronous</strong>,
                      <strong>asynchronous</strong>, and <strong>delegated</strong>.</p>
                  </div>
                  <div id="syncValidation" >
                      <h4>3.3.1 Synchronous validation</h4>

                      <p><strong>Synchronous validation</strong>is the most-common form of validation. In this form of validation, all input elements are validated against constraints synchronously. This
                      means that when you call <code>regula.validate()</code>, the function will perform validation and return constraint-violations. In synchronous validation, the validator performs its
                      validation synchronously, meaning it does not need to <em>wait</em>for something to happen before it report the result of validation. Getting the result of a synchronous validation
                      is as simple as calling the <code>regula.validate()</code>function:</p>
<pre class="prettyprint">
 var constraintViolations = regula.validate();</pre>

                      <p>For more details, see <a href="./documentation.html#regulaValidate">&#167;6.8</a>.</p>
                  </div>
                  <div id="asyncValidation" >
                      <h4>3.3.2 Asynchronous validation</h4>

                      <p><strong>Asynchronous validation</strong>is a form of validation where validation happens after the fact; i.e., it is not synchronous. When validation is initiated, control will
                      return, but validation will still be happening in the background. This form of validation is usually required when some sort of asynchronous operation needs to be performed by the
                      validator, before the validation can report its result. The most-common example is if the validator is internally performing an AJAX request. In this situation, we must wait for the
                      response to return before we can report the result of the validation. To deal with asynchronous validation, you will have to pass a callback to the <code>regula.validate()</code>
                      function:</p>

<pre class="prettyprint">
 regula.validate(function(constraintViolations) {
     ...
 });</pre>

                      <p>For more details, see <a href="./documentation.html#regulaValidate">&#167;6.8</a>.</p>
                  </div>
                  <div id="delegatedValidation" >
                      <h4>3.3.3 Delegated validation</h4>

                      <p><strong>Delegated validation</strong>is where the validation is delegated to another validator (from the <code>validator</code>object). This is typically seen in
                      conditional validation where within the validator, validation is conditionally delegated to some other validator. See <a href="./documentation.html#validators">&#167;3.1.11</a>
                      for an example.</p>
                  </div>
                  <hr />
                  <div id="builtIn" >
                      <h2>4. Built-in Constraints</h2>

                      <p>Regula comes with twenty-three built-in constraints, out of which two are form-specific constraints. Following sub-sections will go over each built-in constraint in detail.</p>
                  </div>

                  <div id="required" >
                      <h3>4.1 @Required</h3>

                      <h4>Overview</h4>

                      <p><code>@Required</code>enforces the constraint that a form field is required. This constraint can apply to a text-box, dropdown, checkbox, radiobutton, or a textarea.
                         <code>@Required</code>is functionally equivalent to explicitly specifying <code>@Checked</code>, <code>@Selected</code>or <code>@NotEmpty</code> on appropriate form elements.
                         It is suggested to use <code>@Required</code>in place of <code>@Checked</code>, <code>@Selected</code>, or <code>@NotEmpty</code>if youâ€™re making sure that the form element
                         has been filled (i.e., use <code>@Checked</code>, <code>@Selected</code>, or <code>@NotEmpty</code>only when semantically appropriate).</p>

                      <h4>Syntax</h4>

                      <p>Syntax for <code>@Required</code>is:</p>
<pre class="prettyprint">
 @Required(
   [label=label-text],
   [message=message-text],
   [groups=array-of-group-names]
 )</pre>

                      <h4>Parameters</h4>

                      <table class="table table-bordered table-striped">
                          <tbody><tr>
                              <th>Name</th>
                              <th>Type</th>
                              <th>Required</th>
                              <th>Description</th>
                          </tr>
                          <tr>
                              <td><code>label</code></td>
                              <td><strong>String</strong></td>
                              <td><em>no</em></td>
                              <td>
                                  An optional parameter that specifies the label for this input element. Labels are a way to provide friendly names to input elements. If the constraint fails to validate,
                                  the value in this field will be used in the default error message. If the constraint has a custom error message which contains <code>{label}</code>, the value of this
                                  parameter will be substituted in the place of <code>{label}</code>.
                              </td>
                          </tr>
                          <tr>
                              <td><code>message</code></td>
                              <td><strong>String</strong></td>
                              <td><em>no</em></td>
                              <td>
                                  An optional parameter that specifies the error message to use when this constraint fails. The value for this field can contain interpolations of parameters used by the
                                  constraint . For example: <code>{label} needs to be {param1}</code>.
                              </td>
                          </tr>
                          <tr>
                              <td><code>groups</code></td>
                              <td><strong>Array</strong></td>
                              <td><em>no</em></td>
                              <td>An array of group names that specifies the validation groups that this constraint belongs to.</td>
                          </tr>
                          <tr>
                              <td><code>ignoreEmpty</code></td>
                              <td><strong>Boolean</strong></td>
                              <td><em>no</em></td>
                              <td>A boolean value that specifies whether this constraint should be validated, if the input-element that it is attached to has an empty value.</td>
                          </tr>
                          </tbody>
                      </table>

                      <h4>Examples</h4>

                      <strong>Basic usage:</strong>
<pre class="prettyprint">
 &lt;input id = "myRadio"
        name = "myRadio"
        type = "radio"
        data-constraints = '@Required' /&gt;</pre>

                      <strong>Usage with optional parameters:</strong>
<pre class="prettyprint">
 &lt;input id = "myTextbox"
        name = "myTextbox"
        type = "text"
        data-constraints = '@Required(label="The fantastic textbox",
                                     message="{label} needs to be checked",
                                     groups=[FirstGroup, SecondGroup, ThirdGroup])' /&gt;</pre>

                  </div>

                  <div id="checked" >
                      <h3>4.2 @Checked</h3>

                      <h4>Overview</h4>

                      <p><code>@Checked</code>enforces the constraint that a radio button, radio-button group, or a checkbox must be checked. If the element in question is not checked,
                      the constraint will fail.</p>

                      <h4>Syntax</h4>

                      <p>Syntax for <code>@Checked</code>is:</p>

<pre class="prettyprint">
 @Checked(
   [label=label-text],
   [message=message-text],
   [groups=array-of-group-names]
 )</pre>

                      <h4>Parameters</h4>

                      <table class="table table-bordered table-striped">
                          <tbody><tr>
                              <th>Name</th>
                              <th>Type</th>
                              <th>Required</th>
                              <th>Description</th>
                          </tr>
                          <tr>
                              <td><code>label</code></td>
                              <td><strong>String</strong></td>
                              <td><em>no</em></td>
                              <td>
                                  An optional parameter that specifies the label for this input element. Labels are a way to provide friendly names to input elements. If the constraint fails
                                  to validate, the value in this field will be used in the default error message. If the constraint has a custom error message which contains <code>{labe}</code>,
                                  the value of this parameter will be substituted in the place of <code>{label}</code>.
                              </td>
                          </tr>
                          <tr>
                              <td><code>message</code></td>
                              <td><strong>String</strong></td>
                              <td><em>no</em></td>
                              <td>
                                  An optional parameter that specifies the error message to use when this constraint fails. The value for this field can contain interpolations of parameters used
                                  by the constraint . For example: <code>{label} needs to be {param1}</code>.
                              </td>
                          </tr>
                          <tr>
                              <td><code>groups</code></td>
                              <td><strong>Array</strong></td>
                              <td><em>no</em></td>
                              <td>An array of group names that specifies the validation groups that this constraint belongs to.</td>
                          </tr>
                          <tr>
                              <td><code>ignoreEmpty</code></td>
                              <td><strong>Boolean</strong></td>
                              <td><em>no</em></td>
                              <td>A boolean value that specifies whether this constraint should be validated, if the input-element that it is attached to has an empty value.</td>
                          </tr>
                          </tbody>
                      </table>

                      <h4>Examples</h4>

                      <strong>Basic usage:</strong>
<pre class="prettyprint">
 &lt;input id = "myCheckbox"
        name = "myCheckbox"
        type = "checkbox"
        data-constraints = '@Checked' /&gt;</pre>

                      <strong>Basic usage with radio-button group:</strong>
<pre class="prettyprint">
 &lt;input id = "myRadio0"
        name = "myRadioGroup"
        type = "radio"
        data-constraints = '@Checked' /&gt; One
 &lt;input id = "myRadio01
        name = "myRadioGroup"
        type = "radio"
        data-constraints = '@Checked' /&gt; Two
 &lt;input id = "myRadio2"
        name = "myRadioGroup"
        type = "radio"
        data-constraints = '@Checked' /&gt; Three</pre>

                      <p><strong>Note:</strong>Strictly speaking, it is not necessary to bind <code>@Checked</code>to each radio-button in a radio-button group; you can just bind it to one. If validation
                      fails, you will get back one constraint-violation and the <code>failingElements</code>attribute of that constraint violation will contain all radio-button elements of the radio-button
                      group.</p>

                      <strong>Usage with optional parameters:</strong>
<pre class="prettyprint">
 &lt;input id = "myCheckbox"
        name = "myCheckbox"
        type = "checkbox"
        data-constraints = '@Checked(label="The fantastic checkbox",
                                     message="{label} needs to be checked",
                                     groups=[FirstGroup, SecondGroup, ThirdGroup]' /&gt;</pre>
                  </div>

                  <div id="selected" >
                      <h3>4.3 @Selected</h3>

                      <h4>Overview</h4>

                      <p><code>@Selected</code>enforces the constraint that a select box must be selected. The constraint validates somewhat by convention; if the <code>selectedIndex</code>property of the
                         select box is <code>0</code>, then the select box is assumed to be unselected because in most cases the â€œunselectedâ€ value is usually the very first option in the select box.</p>

                      <h4>Syntax</h4>

                      <p>Syntax for <code>@Selected</code>is:</p>

<pre class="prettyprint">
 @Selected(
   [label=label-text],
   [message=message-text],
   [groups=array-of-group-names]
 )</pre>

                      <h4>Parameters</h4>

                      <table class="table table-bordered table-striped">
                          <tbody><tr>
                              <th>Name</th>
                              <th>Type</th>
                              <th>Required</th>
                              <th>Description</th>
                          </tr>
                          <tr>
                              <td><code>label</code></td>
                              <td><strong>String</strong></td>
                              <td><em>no</em></td>
                              <td>
                                  An optional parameter that specifies the label for this input element. Labels are a way to provide friendly names to input elements. If the constraint fails to validate,
                                  the value in this field will be used in the default error message. If the constraint has a custom error message which contains <code>{labe}</code>, the value of this
                                  parameter will be substituted in the place of <code>{label}</code>.
                              </td>
                          </tr>
                          <tr>
                              <td><code>message</code></td>
                              <td><strong>String</strong></td>
                              <td><em>no</em></td>
                              <td>
                                  An optional parameter that specifies the error message to use when this constraint fails. The value for this field can contain interpolations of parameters used by the
                                  constraint . For example: <code>{label} needs to be {param1}</code>.
                              </td>
                          </tr>
                          <tr>
                              <td><code>groups</code></td>
                              <td><strong>Array</strong></td>
                              <td><em>no</em></td>
                              <td>An array of group names that specifies the validation groups that this constraint belongs to.</td>
                          </tr>
                          <tr>
                              <td><code>ignoreEmpty</code></td>
                              <td><strong>Boolean</strong></td>
                              <td><em>no</em></td>
                              <td>A boolean value that specifies whether this constraint should be validated, if the input-element that it is attached to has an empty value.</td>
                          </tr>
                          </tbody>
                      </table>

                      <h4>Examples</h4>

                      <strong>Basic usage:</strong>
<pre class="prettyprint">
 &lt;select id = "mySelect"
         name = "mySelect"
         data-constraints = '@Selected'&gt;
     &lt;option value = "0"&gt;Please select a fruit&lt;/option&gt;
     &lt;option value = "1"&gt;Strawberry&lt;/option&gt;
     &lt;option value = "2"&gt;Orange&lt;/option&gt;
     &lt;option value = "3"&gt;Banana&lt;/option&gt;
 &lt;/select&gt;</pre>

                      <strong>Usage with optional parameters:</strong>
<pre class="prettyprint">
 &lt;select id = "mySelect"
         name = "mySelect"
         data-constraints = '@Selected(label="fruit",
                                      message="You need to select a {label}",
                                      groups=[FirstGroup, SecondGroup, ThirdGroup]'&gt;
     &lt;option value = "0"&gt;Please select a fruit&lt;/option&gt;
     &lt;option value = "1"&gt;Strawberry&lt;/option&gt;
     &lt;option value = "2"&gt;Orange&lt;/option&gt;
     &lt;option value = "3"&gt;Banana&lt;/option&gt;
 &lt;/select&gt;
</pre>
                  </div>

                  <div id="notblank" >
                      <h3>4.4 @NotBlank</h3>

                      <h4>Overview</h4>

                      <p><code>@NotBlank</code>(or its alias <code>@NotEmpty</code>) enforces the constraint that an input element cannot have an empty value. An empty value is defined as an empty string,
                          or a string that only consists of spaces or tabs.</p>

                      <h4>Syntax</h4>

                      <p>Syntax for <code>@NotBlank</code>is:</p>

<pre class="prettyprint">
 @NotBlank(
   [label=label-text],
   [message=message-text],
   [groups=array-of-group-names]
 )</pre>

                      <h4>Parameters</h4>

                      <table class="table table-bordered table-striped">
                          <tbody><tr>
                              <th>Name</th>
                              <th>Type</th>
                              <th>Required</th>
                              <th>Description</th>
                          </tr>
                          <tr>
                              <td><code>label</code></td>
                              <td><strong>String</strong></td>
                              <td><em>no</em></td>
                              <td>An optional parameter that specifies the label for this input element. Labels are a way to provide friendly names to input elements. If the constraint fails to validate,
                                  the value in this field will be used in the default error message. If the constraint has a custom error message which contains <code>{labe}</code>, the value of this parameter
                                  will be substituted in the place of <code>{label}</code>.</td>
                          </tr>
                          <tr>
                              <td><code>message</code></td>
                              <td><strong>String</strong></td>
                              <td><em>no</em></td>
                              <td>An optional parameter that specifies the error message to use when this constraint fails. The value for this field can contain interpolations of parameters used by the
                                  constraint . For example: <code>{label} needs to be {param1}</code>.</td>
                          </tr>
                          <tr>
                              <td><code>groups</code></td>
                              <td><strong>Array</strong></td>
                              <td><em>no</em></td>
                              <td>An array of group names that specifies the validation groups that this constraint belongs to.</td>
                          </tr>
                          <tr>
                              <td><code>ignoreEmpty</code></td>
                              <td><strong>Boolean</strong></td>
                              <td><em>no</em></td>
                              <td>A boolean value that specifies whether this constraint should be validated, if the input-element that it is attached to has an empty value.</td>
                          </tr>
                          </tbody>
                      </table>

                      <h4>Examples</h4>

                      <strong>Basic usage:</strong>
<pre class="prettyprint">
 &lt;input id = "name"
        name = "name"
        type = "text"
        data-constraints = '@NotBlank' /&gt;</pre>

                      <strong>Usage with optional parameters:</strong>
<pre class="prettyprint">
 &lt;input id = "name"
        name = "name"
        type = "text"
        data-constraints = '@NotEmpty(label="Your name",
                                     message="{label} cannot be blank"
                                     groups=[FirstGroup, SecondGroup, ThirdGroup]' /&gt;</pre>
                  </div>
                  <div id="blank" >
                      <h3>4.5 @Blank</h3>

                      <h4>Overview</h4>

                      <p><code>@Blank</code>(or its alias <code>@Empty</code>) enforces the constraint that an input element must have an empty value. An empty value is defined as an empty string, or a
                          string that only consists of spaces or tabs.</p>

                      <h4>Syntax</h4>

                      <p>Syntax for <code>@Constraint</code>is:</p>

<pre class="prettyprint">
 @Blank(
   [label=label-text],
   [message=message-text],
   [groups=array-of-group-names]
 )</pre>

                      <h4>Parameters</h4>

                      <table class="table table-bordered table-striped">
                          <tbody><tr>
                              <th>Name</th>
                              <th>Type</th>
                              <th>Required</th>
                              <th>Description</th>
                          </tr>
                          <tr>
                              <td><code>label</code></td>
                              <td><strong>String</strong></td>
                              <td><em>no</em></td>
                              <td>An optional parameter that specifies the label for this input element. Labels are a way to provide friendly names to input elements. If the constraint fails to validate,
                                  the value in this field will be used in the default error message. If the constraint has a custom error message which contains <code>{labe}</code>, the value of this
                                  parameter will be substituted in the place of <code>{label}</code>.</td>
                          </tr>
                          <tr>
                              <td><code>message</code></td>
                              <td><strong>String</strong></td>
                              <td><em>no</em></td>
                              <td>An optional parameter that specifies the error message to use when this constraint fails. The value for this field can contain interpolations of parameters used by the
                                  constraint . For example: <code>{label} needs to be {param1}</code>.</td>
                          </tr>
                          <tr>
                              <td><code>groups</code></td>
                              <td><strong>Array</strong></td>
                              <td><em>no</em></td>
                              <td>An array of group names that specifies the validation groups that this constraint belongs to.</td>
                          </tr>
                          <tr>
                              <td><code>ignoreEmpty</code></td>
                              <td><strong>Boolean</strong></td>
                              <td><em>no</em></td>
                              <td>A boolean value that specifies whether this constraint should be validated, if the input-element that it is attached to has an empty value.</td>
                          </tr>
                          </tbody>
                      </table>

                      <h4>Examples</h4>

                      <strong>Basic usage:</strong>
<pre class="prettyprint">
 &lt;input id = "nothing"
        name = "nothing"
        type = "text"
        data-constraints = '@Blank' /&gt;</pre>

                      <strong>Usage with optional parameters:</strong>
<pre class="prettyprint">
 &lt;input id = "nothing"
        name = "nothing"
        type = "text"
        data-constraints = '@Blank(label="nothing",
                                   message="Don\'t write anything in {label}!"
                                   groups=[FirstGroup, SecondGroup, ThirdGroup]' /&gt;
</pre>

                  </div>
                  <div id="max" >
                      <h3>4.6 @Max</h3>

                      <h4>Overview</h4>

                      <p><code>@Max</code>enforces the constraint that the value of the input element must be lesser than or equal to a specified value</p>

                      <h4>Syntax</h4>

                      <p>Syntax for <code>@Max</code>is:</p>

<pre class="prettyprint">
 @Max(
   value=max-value,
   [label=label-text],
   [message=message-text],
   [groups=array-of-group-names]
 )</pre>

                      <h4>Parameters</h4>

                      <table class="table table-bordered table-striped">
                          <tbody><tr>
                              <th>Name</th>
                              <th>Type</th>
                              <th>Required</th>
                              <th>Description</th>
                          </tr>
                          <tr>
                              <td><code>value</code></td>
                              <td><strong>Integer</strong></td>
                              <td><em>yes</em></td>
                              <td>A required parameter that specifies the maximum acceptable value of the field.</td>
                          </tr>
                          <tr>
                              <td><code>label</code></td>
                              <td><strong>String</strong></td>
                              <td><em>no</em></td>
                              <td>An optional parameter that specifies the label for this input element. Labels are a way to provide friendly names to input elements. If the constraint fails to validate, the value in this field will be used in the default error message. If the constraint has a custom error message which contains <code>{labe}</code>, the value of this parameter will be substituted in the place of <code>{label}</code>.</td>
                          </tr>
                          <tr>
                              <td><code>message</code></td>
                              <td><strong>String</strong></td>
                              <td><em>no</em></td>
                              <td>An optional parameter that specifies the error message to use when this constraint fails. The value for this field can contain interpolations of parameters used by the constraint . For example: <code>{label} needs to be less than or equal to {value}</code>.</td>
                          </tr>
                          <tr>
                              <td><code>groups</code></td>
                              <td><strong>Array</strong></td>
                              <td><em>no</em></td>
                              <td>An array of group names that specifies the validation groups that this constraint belongs to.</td>
                          </tr>
                          <tr>
                              <td><code>ignoreEmpty</code></td>
                              <td><strong>Boolean</strong></td>
                              <td><em>no</em></td>
                              <td>A boolean value that specifies whether this constraint should be validated, if the input-element that it is attached to has an empty value.</td>
                          </tr>
                          </tbody>
                      </table>

                      <h4>Examples</h4>

                      <strong>Basic usage:</strong>
<pre class="prettyprint">
  &lt;input id = "age"
         name = "age"
         type = "text"
         data-constraints = '@Max(value=17)' /&gt;</pre>

                      <strong>Usage with optional parameters:</strong>
<pre class="prettyprint">
 &lt;input id = "age"
        name = "age"
        type = "text"
        data-constraints = '
          @Max(
            value=17,
            label="age",
            message="Your {label} needs to be lesser than or equal to {max}",
            groups=[FirstGroup, SecondGroup, ThirdGroup]
          )' /&gt;
</pre>

                  </div>
              </div>
          </div>
      </div>

    </div><!-- /container -->

    <!-- Bootstrap core JavaScript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="bootstrap/assets/js/jquery.js"></script>
    <script src="bootstrap/js/bootstrap.min.js"></script>
  </body>
</html>

<!--
template

                  <div id="constraint" >
                      <h3>4.x @Constraint</h3>

                      <h4>Overview</h4>

                      <p>overview</p>

                      <h4>Syntax</h4>

                      <p>Syntax for <code>@Constraint</code>is:</p>

<pre class="prettyprint">
syntax</pre>

                      <h4>Parameters</h4>

                      //put table here

                      <h4>Examples</h4>

                      <strong>Basic usage:</strong>
<pre class="prettyprint">
example</pre>

                  </div>
